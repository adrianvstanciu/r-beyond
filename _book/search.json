[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R beyond data analysis",
    "section": "",
    "text": "Preface\n\n\n\nThe book is divided into several chapters as follows:\n\nChapter 1  General introduction: This is an introduction to the purpose and mission of this seminar, and provides useful information to get one started.\nChapter 2  R universe: This part is a gentle introduction in the r universe.\nChapter 3  Automatization: This part addresses the notion of automatization of workflows.\nChapter 4  Self-publish: This part provides tips on self-publishing content online.\nChapter 5  Shiny apps: This part introduces shiny-apps as tools for communicating research output.\nChapter 6  Parting words: This is an overview of the learned material and contains some tips for individual work.\n\nTo illustrate the benefits of working with R beyond data analysis while transitioning to a holistic work flow, we will build on an example that evolves throughout the chapters 3  Automatization–5  Shiny apps.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  General introduction",
    "section": "",
    "text": "Why this seminar?\nThe are a couple of reasons why someone might be interested in using r beyond data analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>General introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#why-this-seminar",
    "href": "intro.html#why-this-seminar",
    "title": "1  General introduction",
    "section": "",
    "text": "1.0.1 Reason 1\nFirst, r is a programming language thus it is a gateway to other “hard-core” programming languages. For someone who wants to re-invent oneself, r can be a useful companion during transitioning from closed-ended data analysis software like SPSS, Mplus or Stata toward a language based logic in data analysis which can be elevated to a holistic work flow.\nWhen using data analyis software like SPSS, Mplus or Stata, one has at one’s disposal powerful tools specifically designed to cover the unique purposes of data analysis. This means however also that one needs to simultaneously master a number of other software in writing up, storing and disseminating one’s work. A typical work routine involves:\n\nimporting a dataset in the preferred data analytical software like SPSS,\nperforming the needed analyses,\ncopy/ pasting the result output into a text editor like Word,\nbouncing forth and back between steps a, b, and c until final results are ready,\nsaving the manuscript as a PDF copy.\n\nSometime, when one follows the open science practices, there are a couple of extra steps involved:\n\nupload the PDF copy to an online repository,\nupload scripts and material to the online repository (after ensuring a good documentation),\n\nMeanwhile, with the help of r one can develop a work routine wherein all the “a” through “g” steps, as well as several other, can be integrated into one work flow in time.\n\n\n1.0.2 Reason 2\nThe second reason why one might be interested in r beyond data analysis is the appeal of using an open source and community maintained work environment.\nThis usually means that a dedicated team of specialists develop and maintain software like SPSS, Mplus or Stata which most often than not is available against costs. On the other hand, r is open source which means that the code is publically available and everyone can contribute to its development. The Cran website hosts an archive and recent developments.\n\n\n1.0.3 Reason 3\nThird, r is a programming language around which a number of excelent tools have been developed. All of these tools, some of which are covered in this seminar, are likewise open source and can be used in an integrated work environment. This means that if one wants to transition to r, one can have access to a universe of new posibilities including, for example, creating websites, web applications as well as working seamlessly and simultaneously with several other programming languages including python and SQL.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>General introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#what-else-is-good-to-know",
    "href": "intro.html#what-else-is-good-to-know",
    "title": "1  General introduction",
    "section": "What else is good to know?",
    "text": "What else is good to know?\n\n1.0.4 Some wizardry stuff\nWell, if you know programming, it is all too easy. If you don’t, nothing makes sense.1\nOne of the first things that one needs to do before using r beyond data analysis is to connect all the dots so-to-speak. r beyond data analysis relies on an integrated work environment that includes the programming language itself r, a work environment interface like RStudio as well as online repositories and servers, for general purposes like GitHub and for specific purposes like shiny-apps the shinyapp.io.\nTo seamlessly write code and publish it online while ensuring that it does what it is supposed to, there has to be an open channel between all these elements – the work environment needs to be integrated, that is.\nTo integrate all of these things one needs:\n\nan account on these platforms,\nestablishing a communication channel between platforms and working machine (your personal computer),\nencrypting this communication channel.\n\nI won’t cover all the required steps into detail here. This online resource provides everything one needs.\nFor the sake of simplicity, which happens to be the fundamental piece for the work flow we address in this seminar, one needs to have Git installed on one’s local machine. You might already have it, so please check it first. Note that installing Git might take some time, so don’t be surprised if that happens.\n– Install for Windows by downloading from https://gitforwindows.org/ (here).\n– Install for Mac or Linux using Homebrew. Follow the steps here https://brew.sh/(here).\n\n\n\n\n\n\nTip 1.1: About Git\n\n\n\nGit is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency https://git-scm.com/.\n\n\n\n\n1.0.5 GitHub\nTechnically, this section and the one above are difficult to tease apart. For those interested, this online resource can answer further questions and is a good starting point for an advanced workflow with r, Git and GitHub.\nGitHub is an online platform that facilitates collaboration, storage and publishing of almost anything programming-related. It is an online and publically accessible repository in that anyone with an account can create repositories, upload and download codes and projects. Basically it is facebook for programmers.\nA relative of GitHub is GitLab which is specifically designed for internal use in institutions. If you want to publish your code online (website and online books, for example) and make it accessible to everyone in the world then you should use GitHub. If however, you’d like to work on a project internally, only with colleagues from your institution (or other registred institutions) you should use GitLab, which is available through your institutions. At the University of Luxembourg, there is a designated GitLab platform.\nOpen an account on https://github.com/.2\nAfter the GitHub account is live, the next step is to open and encrypt the communication channel between your local machine and your GitHub repository account. This step can be tricky, so take your time and equip yourself with lots of patience. All the steps can be found here. A simplified, and somewhat visual, description is provided also here3\n\n\n1.0.6 Pushing, pulling, cloning and commiting\nIt is helpful to understand first the concepts of pushing, pulling, cloning and committing. These are verbs in the English language thus they indicate actions that one can do. These actions all are in reference to the code one writes and the current location of the code and where one wants the code to be placed.\n\npushing is basically the action of uploading the written code or files from the local machine onto the online repository through the distribution control system, Git that is. pushing only has a resemblance to uploading because pushing a code onto an online repository means simultaneously uploading it and creating a history of the code in the project. In some cases, pushing a code also means it “activates its” functions. In chapter Chapter 4, for example, we will see that the written code on the local machine becomes a book or a website once it is pushed onto the GitHub online repository.\npulling is in many ways the opposite of the pushing verb. In this case, one is downloading the code or files from the online repository on the local machine. This can come in handy when one is working with others on a common project, and, while gone, someone else has updated the project; Someone else has pushed a code update, for example. Also, this is a useful thing when one uses variant machines or when one has deleted by mistake the project from the local machine, which can happen!\ncloning is in many ways copy-pasting a repository from the online GitHub server to the local machine. The outcome is a straightforward one: Cloning a repository to the local machine means also that the history, code changes and dependencies are reproduced on the local machine.\ncommitting is exactly what you think it might mean in the English language – to commit to something or someone has a finality aspect to it, or enduring, or fixed, if you will. When writing code or changing code (or files for that matter) on the local machine, you commit it to your project when you are happy with it. This then means that the updated code is now integrated in the project, it can be traced backwards in the history of the project. The nice thing about working this way is that once a code update or file is committed to the project, the project itself is updated/ modified accordingly.\n\n\n\n1.0.7 GitHub client\nWriting code and creating Rmarkdown files on the local machine is rather straightforward. For that, one needs only an r client, and typically RStudio (download here, will be covered in more detail in Chapter 2) is the preferred one.\nHowever, as soon as online repositories, collaborative work and co. become relevant, one needs to communicate with these non-local machines.\nOne way to do this is through line coding in git, which can be accessed via the Terminal in the RStudio. This can be straightforward and eventually becomes a routine. This cheet sheet provides all the necessary gitcommands.\nMeanwhile, if one prefers using git through a friendlier visual interface, then one would want a GitHub client. GitHub Desktop can be downloaded for free and has a simple interface. Check this resource to getting started with GitHub Desktop.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>General introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#illustrative-example",
    "href": "intro.html#illustrative-example",
    "title": "1  General introduction",
    "section": "Illustrative example",
    "text": "Illustrative example\n\n1.0.8 Background\nThroughout Chapter 3–Chapter 5, we will use a sample of the data reported in Stanciu et al. (2017)4.\nStanciu et al. (2017) studied how people stereotyped varying social groups in terms of warmth and competence across several regions in Romania. For this seminar, we will use data from a sample of n = 100 participants selected at random from the reported data set.\nThe data includes the following variables:\n\nppn participant number,\ngen self-reported gender of participant as female (1) or male (2),\nage chronological age as it was self-reported in years,\nres region or residence of the participant,\nres_other open ended question regarding region or residence of the participant,\nmen_warm participant’s stereotypeical evaluation of men in terms of warmth,\nmen_comp participant’s stereotypeical evaluation of men in terms of competence,\nwom_warm participant’s stereotypeical evaluation of women in terms of warmth,\nwom_comp participant’s stereotypeical evaluation of women in terms of competence.\n\nStereotypical evaluations were assessed on Likert scales with these answer options:\n1 = strongly disagree, 2 = disagree, 3 = undecided, 4 = agree, 5 = strongly agree.\n\n\n\n\n\n\nTip 1.2: Access data\n\n\n\nData and meta-data referred throughout this short book are downloadable directly from inside this book. Navigate to the left panel of the book, and press the download icon under book title.\nLikewise, all r scripts, .Rmd and .qmd illustrative examples are provideed in .zip compressed files.\n\n\n\n\n1.0.9 The plan\nIn Chapter 3 we will use this sample to illustrate how certain steps in working with data can be automatized. We will write static text and “living” texts whereby we use r code to populate text dynamically with information automatically retrieved directly from data.\nIn Chapter 4 we will see how the work from previous chapter can be integrated in a self-published book or as content for the personal website. We will focus on creating tables and graphs using the sample.\nIn Chapter 5 we will see how we can present results in an interactive manner using online applications. We will focus on how to create tables and graphs as well as “live” texts for the online app.\n\n\n\n\nStanciu, A., C. J. Cohrs, K. Hanke, and A. Gavreliuc. 2017. “Within-Culture Variation in the Content of Stereotypes: Application and Development of the Stereotype Content Model in an Eastern European Culture.” The Journal of Social Psychology 157 (5): 611–28. https://doi.org/10.1080/00224545.2016.1262812.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>General introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  General introduction",
    "section": "",
    "text": "I estimate I know about 0,01 %.↩︎\nNote that it is not quite clear where the data is stored on these servers. So, if you are concerned about data protection issues, be sure you do not upload sensitive information. For the sake of this seminar this is not an issue, but be warned!↩︎\nThis resource is also a step-by-step guide for creating a website using r and associated tools. This will be covered is Chapter 4 of this short book.↩︎\nThe article can be downloaded also via Orbilu at the University of Luxembourg. See here↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>General introduction</span>"
    ]
  },
  {
    "objectID": "runiv.html",
    "href": "runiv.html",
    "title": "2  R universe",
    "section": "",
    "text": "R (the console and language)\nWhen most people talk about r they mean both the programming language and a console. Unless they are IT experts who can make the distinction with ease. But, for the purpose of the seminar, or as a typical r-user for what is worth, it really doesn’t matter.\nWhen working with r one needs a designated console for writing the code, and this is easy to detect as r-console (see Figure Figure 2.1).\nTo download R, go to the cran website and select the file suitable for your operating system. Unzip or install that file and the r-console will be installed on your machine.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#r-the-console-and-language",
    "href": "runiv.html#r-the-console-and-language",
    "title": "2  R universe",
    "section": "",
    "text": "Figure 2.1: The R console",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#the-basics-the-very-basics",
    "href": "runiv.html#the-basics-the-very-basics",
    "title": "2  R universe",
    "section": "The basics (the very basics!)",
    "text": "The basics (the very basics!)\nThis seminar will cover only the very absolute basics of working in r. Designated courses are available at the university and elsewhere as part of summarschools or workshops. Of course, one can learn r using the freely available online content. Use YouTube and Google for that. For example, this online resource is a good starting point.\nThe first thing to notice in the r console is the symbol &gt; followed by the text placer |. This specifies the line where to write the r code.\nOnce the code is written and the key Enter is pressed, the code basically runs or is computed by the machine which returns an outcome. (Here the symbol &gt; is not visible but the outcome line can be identified through the use of squared brackets[…])\n\n2+2\n\n[1] 4\n\n\n\n2.0.1 Objects\nIt is useful to work with objects in r. That is, whatever code you write, place it into an object and then run the object itself. See below.\n\n# no object created\n2+2\n\n[1] 4\n\n# object is first created and then run\nsum&lt;-2+2\nsum\n\n[1] 4\n\n\nUsing objects simplifies a lot the work flow because you can combine objects in any way you can imagine!\n\n# creates a second object called mean\nmean&lt;-mean(c(1,2,5,7,8,9))\nmean\n\n[1] 5.333333\n\n# and then adds the two objects 'sum' and 'mean' together\nresult&lt;-sum+mean\nresult\n\n[1] 9.333333\n\n\n\n\n2.0.2 Vectors\nThere are multiple types of objects that one can create in r. The most important ones are vectors and data tables.\nFor simplicity reasons, vectors can be numeric, character strings or logical. A vector is scalable meaning that it can hold up to a gazilion of elements.\n\n# example of numeric vectors\nvec1&lt;-c(1,3,66,9,121)\nvec1\n\n[1]   1   3  66   9 121\n\n# example of character string vector\nvec2&lt;-c(\"A\",\"Ab\",\"This or that\",\"C\",\"d\")\nvec2\n\n[1] \"A\"            \"Ab\"           \"This or that\" \"C\"            \"d\"           \n\n# example of logical vector\nvec3&lt;-c(TRUE,TRUE, FALSE, TRUE)\nvec3\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\nOne can do all sorts of things with and to vectors. See for example here.\n\n\n2.0.3 Data tables\nData tables combine multiple vectors. Data tables can combine all sorts of vectors and can have varying internal structures. When one downloads (or uses one own’s) dataset, that is typically a data table in a specific format, .sav for SPSS or .xlsx for Microsoft Excell. Data formats can also be .dat, .csv, .asci and so on.\nA data table in r comprises multiple vectors and involves an organization wherein typically rows represent entries in the data table and columns represent vectors of the data table. In other words, rows represent cases and columns represent variables.\n\n# create a simple data table\ndf&lt;-data.frame(col1=vec1,\n                  col2=vec2)\ndf\n\n  col1         col2\n1    1            A\n2    3           Ab\n3   66 This or that\n4    9            C\n5  121            d\n\n\n\n# one can then access the varying elements of the data table\n\n# access col1\ndf[,1]\n\n[1]   1   3  66   9 121\n\n# access first row\ndf[1,]\n\n  col1 col2\n1    1    A\n\n# access entry at first row and col1\ndf[1,1]\n\n[1] 1\n\n\nOne can perform all sorts of actions on the data table as a whole or on elements of the data table.\n\n# checks the elements of the data table\nstr(df)\n\n'data.frame':   5 obs. of  2 variables:\n $ col1: num  1 3 66 9 121\n $ col2: chr  \"A\" \"Ab\" \"This or that\" \"C\" ...\n\n\nOne can see that col1 is a numeric num vector and col2 is a character string char vector.\n\n# provides a summary of the data table\nsummary(df)\n\n      col1         col2          \n Min.   :  1   Length:5          \n 1st Qu.:  3   Class :character  \n Median :  9   Mode  :character  \n Mean   : 40                     \n 3rd Qu.: 66                     \n Max.   :121                     \n\n\nOne can see that different summary stats are available for num and chr vectors.\n\n# performs an addition on the numeric vector of the data table\ndf[,1]+100\n\n[1] 101 103 166 109 221",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#functions",
    "href": "runiv.html#functions",
    "title": "2  R universe",
    "section": "Functions",
    "text": "Functions\nTo be entirely honest, r functions are something a bit advanced. But, some rudimentary functions can be written by beginners too. The trick is to figure out what is repetitive in the code that one wants to write. This logic proves useful when one needs to apply a command on a number of objects for an undetermined number of times.\nFunctions are easy to spot in R because they are labeled as such and have a unique code structure: function(){}.\nThe rule of thumb is () defines the elements that are fed into the function while {} contains the function itself.\nHere is an example. We use a dataset that comes pre-installed with R (iris), perform an addition on all the numerical variables and then write a function to simplify the task.\n\n# see the first ten rows of the pre-installed dataset iris\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n# numerical columns are then columns 1 through 4\n\n# adds 3 to all numerical columns\nhead(iris[,1:4] + 3)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1          8.1         6.5          4.4         3.2\n2          7.9         6.0          4.4         3.2\n3          7.7         6.2          4.3         3.2\n4          7.6         6.1          4.5         3.2\n5          8.0         6.6          4.4         3.2\n6          8.4         6.9          4.7         3.4\n\n# add 77 to all numerical columns \nhead(iris[,1:4] + 77)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1         82.1        80.5         78.4        77.2\n2         81.9        80.0         78.4        77.2\n3         81.7        80.2         78.3        77.2\n4         81.6        80.1         78.5        77.2\n5         82.0        80.6         78.4        77.2\n6         82.4        80.9         78.7        77.4\n\n# write a function \n# this function takes two arguments: a dataset 'df' and a constant 'n'\nfunc1&lt;-function(df,n){\n  \n  tmp &lt;- Filter(is.numeric, df) # we first filter the dataframe for numeric columns\n  \n  tmp + n # we then add the constant to all the numeric columns\n}\n\n\n# we apply the function and add 3 to all numeric columns of iris\n# we only ask to see the first ten rows of the outcome using head()\nhead(func1(iris,3))\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width\n1          8.1         6.5          4.4         3.2\n2          7.9         6.0          4.4         3.2\n3          7.7         6.2          4.3         3.2\n4          7.6         6.1          4.5         3.2\n5          8.0         6.6          4.4         3.2\n6          8.4         6.9          4.7         3.4\n\n# we apply the function and add 99 to all numeric columns of another pre-installed dataset 'mtcars'\n# we only ask to see the first ten rows of the outcome using head()\nhead(func1(mtcars,99))\n\n                    mpg cyl disp  hp   drat      wt   qsec  vs  am gear carb\nMazda RX4         120.0 105  259 209 102.90 101.620 115.46  99 100  103  103\nMazda RX4 Wag     120.0 105  259 209 102.90 101.875 116.02  99 100  103  103\nDatsun 710        121.8 103  207 192 102.85 101.320 117.61 100 100  103  100\nHornet 4 Drive    120.4 105  357 209 102.08 102.215 118.44 100  99  102  100\nHornet Sportabout 117.7 107  459 274 102.15 102.440 116.02  99  99  102  101\nValiant           117.1 105  324 204 101.76 102.460 119.22 100  99  102  100",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#packages",
    "href": "runiv.html#packages",
    "title": "2  R universe",
    "section": "Packages",
    "text": "Packages\nAn R package contains code, documentation, and sometimes even data. These packages are developed to serve a specific purpose such as simplifying a work routine or perform advanced computational routines. Packages can be downloaded for free and then immediately used. Of course, everyone can write an R package, which of course is not a easy thing to do. But if at any point and for whatever reason you need to, then know that it is possible.\nEverything one needs to know about packages can be found in this comprehensive book by Hadley Wickham1 and Jennifer Bryan.\nr packages use the philosophy of working with functions to simplify otherwise highly complex code. Some of the fundamental packages to start with are tidyverse (for data preparation and manipulation but also contains several other useful packages like ggplot2 for creating graphics). Other packages that are the focus of this seminar are rmarkdown (the fundamentals of Chapter 3 through Chapter 5), quarto (needed for self-publishing books and website; covered in Chapter 4),tinytex (for latex distributions aka. creating PDFs), shiny (for web applications; covered in Chapter 5).\nWhat you absolutely need to know about packages is that the vast majority do not come pre-installed with the r console but can be installed by request. Installing any package in R follows this basic routine:\n\n# installs `tidyverse`\n install.packages(\"tidyverse\") \n\n# makes it available for R on your local machine\n# this step is crucial if you want to have access to all the containing function\nlibrary(tidyverse)\n\nOne trick that I think it is absolutely simple to use but can save you a lot of nerves is using the package pacman to install any other packages. The nice thing about it is that pacman can first check if a package is already installed on the local machine and if not, it downloads it and installs it from Cran.\nWe can now install the basic packages needed for the seminar and mentioned above.\n\n# first, we install the `pacman` package\ninstall.packages(\"pacman\")\n\n# then, we use the function `p_load` from the `pacman` package to install `tidyverse`, `rmarkdown`, `shiny` packages\npacman::p_load(tidyverse,rmarkdown,bookdown,quarto,shiny)\n\n\n\n\n\n\n\nTip 2.1: R Packages with websites\n\n\n\n(Almost) Every package has a designated website. Visit the package website for examples on how to use and also to identify the functions contained. For example https://www.tidyverse.org/\n\n\n\n\n\n\n\n\nTip 2.2: R Packages documentation\n\n\n\nCall the package documentation by typing in a question mark followed by the name of the package or function contained in a package. For example ?tidyverse\n\n\nLet’s see as an example how the function filter from the universe of packages tidyverse works. Before that, I want to introduce the pipe operator %&gt;%2 which is instrumental for r users. And it simplifies a lot the work flow!\n%&gt;% follows the logic of, simply and un-elegantly put, “work that happens in the background until the desired output is retrieved”. It also means that using %&gt;% you can compress into one code otherwise a long chain of steps that involve creating objects which are then subjected to new operations.\n\n# apply the function filter to the dataset mtcars\n# we filter the column cyl such that only cars with a cyl &lt; 5 are displayed\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nmtcars %&gt;% filter(cyl &lt; 5)\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# we filter the column cyl such that only cars with a cyl exactly equal to 8 are displayed\nmtcars %&gt;% filter(cyl == 8)\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n\n\nAs an example of the usefulness of the pipeline operator %&gt;%, let us apply a double filter. First, on the column cyl and then on the column horse power hp.\n\n# without the pipeline operator\na&lt;-mtcars %&gt;% filter(cyl &lt; 5)\nb&lt;-a %&gt;% filter(hp &gt; 100)\nb\n\n              mpg cyl  disp  hp drat    wt qsec vs am gear carb\nLotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nVolvo 142E   21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n# with the pipeline operator\nmtcars %&gt;% filter(cyl &lt; 5) %&gt;% filter(hp &gt; 100)\n\n              mpg cyl  disp  hp drat    wt qsec vs am gear carb\nLotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nVolvo 142E   21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n\nOf course, this example is too simplistic but imagine having to write a gazillion of lines of code when you could reduce that to a couple. Throughout the seminar we use the pipe operator %&gt;% almost everywhere!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#base-r-vs.-packages",
    "href": "runiv.html#base-r-vs.-packages",
    "title": "2  R universe",
    "section": "Base R vs. Packages",
    "text": "Base R vs. Packages\n\n\n\n\n\n\nFigure 2.2\n\n\n\nA fair warning!\nBase R is complex but stable. Packages are simple to use but depend on the community for their maintenance. So, the decision is to use something complex but stable or simple but unstable.\nFor the purpose of this seminar, and for most of the things a regular R-user needs, working with packages is indeed the way to go.\nIf at any point, you are concerned that the package(s) you use can get outdated, I recommend using the [sic!] package groundhog which ensures reproducible code. This package basically goes back in time and installs on the local machine the desired version of the package.\nSee how it works on this website.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#rstudio",
    "href": "runiv.html#rstudio",
    "title": "2  R universe",
    "section": "RStudio",
    "text": "RStudio\n\n\n\n\n\n\nFigure 2.3: RStudio panels\n\n\n\nIn Figure 2.3 you can see the four panels of RStudio, the (a) Console/terminal, (b) Source, (c) Environment/history, and (d) Files/plot/packages/help.\n\na) Console/terminal Here is where the r console is integrated in RStudio. You can type in your code, have your results previewed, as well as any errors (those happen quite a lot) that occur in your coding.\nb) Source This panel is where we will do most of the work throughout the seminar. Think of this panel as the notebook – you write, you draw, you comment on your own work, etc. This panel allows you to communicate with the source material, which can be r (the language), html (the language) and also lets you populate with content the files needed for the website, for instance.\nc) Environment/history This panel is a place where you can see the history of your work. It saves for you the code you ran (either in the console or source panels) and also it contains sort of short-cuts to any data-related work you might have done.\nd) Files/plot/packages/help This panel allows you to preview what you’ve communicated to the machine (laptop) to do. You will note there are several tabs, but the most important one for the seminar are:\n\nFiles is sort of Windows explorer in Windows or Finder on Mac OS. It is here that you can navigate between folders on the local machine, delete, rename, or more. Here you can also open files in the source panel.\nPackages gives you an overview of packages that are installed and active on the local machine.\nHelp is, well, where you will see helpful information about a function or package.\n\n\nOn this youtube channel there is a helpful beginners guide on R and RStudio. Take some time to familiarize yourself with them.\n\n\n\n\n\n\nTip 2.3: Learning resources\n\n\n\nIf your RStudio version is 2024.04. or newer, you should note in the Environment/ History panel a tab “Turorial”. That panel contains tutorials for working in R. Install first the package learnr as indicated and let yourself guided through a number of interactive exercises.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#advanced-resources",
    "href": "runiv.html#advanced-resources",
    "title": "2  R universe",
    "section": "Advanced resources",
    "text": "Advanced resources\nTogether with a colleague, Dr. Ranjit SINGH from GESIS - Leibniz Institute for the Social Sciences, I prepared a workshop on r for beginners. All the material is open access via GitHub.\nYou can clone the repository on your local machine and do all the exercises.\nNavigate first to the page of the repository and then clone it to your local machine: https://github.com/adrianvstanciu/rworkshop_open.\n\n\n\nFigure 2.1: The R console\nFigure 2.2: \nFigure 2.3: RStudio panels",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "runiv.html#footnotes",
    "href": "runiv.html#footnotes",
    "title": "2  R universe",
    "section": "",
    "text": "He is THE r expert. See his website.↩︎\nThe pipe operator itself is introduced most comonly in the package dplyr contained in the universe of packages tidyverse. But, it can be used differently in other packages too.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R universe</span>"
    ]
  },
  {
    "objectID": "autom.html",
    "href": "autom.html",
    "title": "3  Automatization",
    "section": "",
    "text": "Elements and structure\nThe first thing we need is to install the package rmarkdown (and all dependencies, meaning all the packages that rmarkdown needs to function properly). An introduction to R Markdown is available on the official website1.\n# installs package `rmarkdown` and all dependencies\ninstall.packages(\"rmarkdown\", dependencies = TRUE)\nAfter the package rmarkdown, including its dependencies, is successfully installed, we should be able to create and work in .Rmd files.\nCreate your first .Rmd file and give it a name. For example, example.Rmd. You should see it now lower-right panel Files/Packages/Help.\nOnce the .Rmd has been created, you should be able to open and edit it. It should look like this.\nIn Figure 3.2 there are numbered lines from 1 to 30. These indicate lines in the rmarkdown file. We refer to these to discuss elements of the file.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "autom.html#elements-and-structure",
    "href": "autom.html#elements-and-structure",
    "title": "3  Automatization",
    "section": "",
    "text": "Figure 3.1: Create your first RMarkdown file\n\n\n\n\n\n\n\n\n\nTip 3.1: Workflow simplified with projects\n\n\n\nI recommend always working with R projects which makes it easy for code dependencies and gives structure to your work flow. To associate your project to an .Rproj, go to File and create a New project. Make sure you associate the current folder you are working in with the Rproj. This guide can help further.\n\n\n\n\n\n\n\n\n\nFigure 3.2: RMarkdown document\n\n\n\n\n\nLines 1 through 5 (note the ---) hold the yaml header element. Here is where you indicate the characteristics of the entire rmarkdown document, and it includes for example the kind of output file you want generated, title of the document or date of the document version. Many other yaml attributes exist and depending on your goals, you can easily find them online using a version of the search string yaml rmarkdown attributes.\nLines 7 through 9 (as well as 17-20 and 25-27) are code chunks. In this case, they are r code chunks, as signaled by the small letter r. Code chunks are what makes rmarkdown documents so powerful. Integrating code chunks into text facilitates the creation of live documents. In other words, plain text merged with code. Each code chunk has multiple attributes that can modify the way the output of the code is integrated and presented in the output document. Note for example at line 7 {r setup, include=FALSE}.\n\nsetup is the name of the code chunk and this is extremely helpful to give structure to the document but also when cross-referencing figures and tables in the document.\n, the comma is crucial here because it signals that what follows are settings of the code ouput\ninclude=FALSE is one such setting attribute and indicates that the code output is not integrated in the output document BUT it runs in the background.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "autom.html#knit",
    "href": "autom.html#knit",
    "title": "3  Automatization",
    "section": "Knit",
    "text": "Knit\n\n\n\n\n\n\nFigure 3.3\n\n\n\nFigure 3.3 is an overview of the workflow from an .Rmd (editable rmarkdown document) to an output document which can be .pdf, .html, .docx and so on. One crucial step happens during the knit of .Rmd file. Basically, in this step you knit everything from the .Rmd document together. The name comes from knitting, which is, well, creating something nice and creative from nothing.\n\n\n\n\n\n\nFigure 3.4: Knited bike cover\n\n\n\nIn fact, the very Figure 3.4 above was knited to the final document.\nThe knit function comes pre-installed with RStudio and can be found in the source panel. Identify it, and knit your first .Rmd file first into a .pdf and then into a .html file.\n\n\n\n\n\n\nTip 3.2: Latex distributions for PDF\n\n\n\nIf knit to PDF didn’t work, it might be because we need a latex distribution on the machine that r can work with. Try installing the package tinytex (Read more on https://yihui.org/tinytex/)\n\n\n\n# to install tinytex distribution \ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# to uninstall TinyTeX, run tinytex::uninstall_tinytex() \n\nOnce you knit the .Rmd file, a new file will be created in the designated folder. Voilà - you just created your first PDF and/ or HTML document.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "autom.html#live-documents",
    "href": "autom.html#live-documents",
    "title": "3  Automatization",
    "section": "Live documents",
    "text": "Live documents\nFor the purpose of this seminar, I call live documents those documents that are coded to retrieve data and/ or information from external source material (e.g., datasets or meta-data such as from Excel sheets). This is the building block for creating all sorts of automatized reports.\n\n3.0.1 Path dependencies\nSince we are working inside an .Rproj, all dependencies are already set up. This helps because when interacting with external source material we need to specify where the code should look for it. This is possible also without working in an .Rproj but the dependencies are increasingly more complex to set up. For one, the migration from one operating system to the other may break these dependecies. Furthermore, you need to find the file path on the local machine and then include it in the code. Note that in case of deploying (uploading) the project on GitHub the code will break because, of course, the dependencies are only locally relevant. If, however, we work in .Rproj and we push all the project files on GitHub, then we need not worry about file paths, these are by default set up through the use of the project.\nReturn to the first .Rmd we previously created. Open it in RStudio.\nOnce opened, we may choose to delete the default content, leaving only the yaml header intact. Or we may choose to keep the default content. I choose to delete it for the sake of simplicity.\n\n\n3.0.2 The set up\nWe can start by setting up the work environment. This means, we should first install the packages we’d need in the process.\nWe install using pacman the packages tidyverse, readxl (for reading Excel sheets), haven (for reading SPSS files), sjlabelled (for dealing with labelled dataframes), kable and kableExtra (for creating tables).\n\ninstall.packages(\"pacman\")\n\npacman::p_load(tidyverse,readxl,haven,sjlabelled,kable, kableExtra)\n# note: this exact code chunk might end up looking differently in the short book\n# this is becauase i'd install packages as needed\n\n\n\n3.0.3 Importing data\nNext, we import our dataset in .sav format and the Excel sheet in .xlsx format. This will allow us access to the contents of those external source material which we can integrate in our final document.\nTo import these external source material, remember to use objects to store that information. In other words, we import the source material and assing it to objects that we can then perform varying actions onto.\n\n# create an object dataframe example `dfex` and assign to it the .sav file `sample.sav` that was introduced previously\ndfex&lt;-haven::read_sav(\"data/sample.sav\")\n\n# create an object movies metadata `dfmv` and assign to it the .xlsx file `movies.xlsx`\n# note the different paths to these files\n# note that we specify which sheet to read too; here only sheet 1 is imported\ndfmv&lt;-readxl::read_excel(\"mat/movies.xlsx\",1)\n\n# next, we check if the source material was imported successfully by observing the first lines in the tables\nhead(dfex)\n\n# A tibble: 6 × 9\n    ppn gen          age res       res_other men_warm men_comp wom_warm wom_comp\n  &lt;dbl&gt; &lt;dbl+lbl&gt;  &lt;dbl&gt; &lt;dbl+lbl&gt; &lt;chr&gt;     &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt;\n1   459 1 [Female]    24  5 [Iasi] -99        3 [Und…  4 [Agr… 3 [Unde… 4 [Agre…\n2   592 2 [Male]      21  5 [Iasi] -99        3 [Und…  4 [Agr… 3 [Unde… 3 [Unde…\n3   634 2 [Male]      21 NA        petrosani  4 [Agr…  5 [Str… 4 [Agre… 4 [Agre…\n4   369 1 [Female]    30  8 [Gala… -99       NA       NA       4 [Agre… 4 [Agre…\n5   121 1 [Female]    21  4 [Timi… -99        4 [Agr…  3 [Und… 3 [Unde… 4 [Agre…\n6   127 1 [Female]    20  4 [Timi… -99        4 [Agr…  4 [Agr… 4 [Agre… 2 [Disa…\n\nhead(dfmv)\n\n# A tibble: 4 × 6\n  Movie                       Actor                 Like  Why     Grade Wikilink\n  &lt;chr&gt;                       &lt;chr&gt;                 &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;   \n1 John Wick                   Keanu Reeves          Yes   Fight …    10 https:/…\n2 Call me by your name        Timothee Chalamet     Yes   Beauti…    10 https:/…\n3 Terminator                  Arnold Schwarzenegger Yes   Arnold      9 https:/…\n4 4 months 3 weeks and 2 days &lt;NA&gt;                  Yes   Portra…     8 https:/…\n\n\n\n\n\n\n\n\nFigure 3.5: Example .Rmd file\n\n\n\nIf all went well, your .Rmd should look similar to mine (see Figure 3.5).\n\n\n3.0.4 Plain text vs. live text\nIn some ways, what we have coded thus far is also an automatized work routine in that the .Rmd document automatically retrieves the external source material every single time when it is knit-ed into a PDF or HTML file.\nThis is however not so helpful because the display of those contents are static, or as plain information. Static in the sense that we would still have to read and retrieve the desired summary and/ or information from specific combinations of rows-columns by hand.\nWith a bit of work we can transition from plain text to live text. And here is where the proper automatization of the work flow begins.\nWith live text, or in-line code, we can integrate code chunks into plain text so that through knit function rmarkdown automatically enhances the plain text with the desired information from the external source material. This can be extremely helpful when writing repetitive reports, for instance Another example is when we want to quickly have a look at progress of a data collection process.\nThe tricky part with live text is to know exactly what to retrieve from the external source material and in what kind of vector that information is stored. Character (text) and numerical vectors behave differently and have different characteristics.\nLet us write our first short paragraph that integrates plain text and live text.\n. . .\nBEGIN EXAMPLE\nThis is an example of how automatization can be implemented in the work flow. My list of movies include 4 entries. The title of those movies are John Wick, Call me by your name, Terminator, 4 months 3 weeks and 2 days. Is there a movie that I actually don’t like on that list, well, the answer is that I dislike exactly 0 movies on that list.\nEND EXAMPLE\n. . .\nThis is tricky to observe here, so I attach an image of the actual .Rmd document.\n\n\n\n\n\n\nFigure 3.6: Live paragraph in .Rmd\n\n\n\nCopy the text from this code chunk into your .Rmd file and it should look like in Figure 3.6.\n\nThis is an example of how automatization can be implemented in the work flow. My list of movies include `r nrow(dfmv)` entries. The title of those movies are `r dfmv$Movie`. Is there a movie that I actually don't like on that list, well, the answer is that I dislike exactly `r dfmv %&gt;% filter(Like %in% c(\"No\",\"no\",\"NO\")) %&gt;% nrow()` movies on that list.\n\n\n\n3.0.5 Live text in focus\nWe’ve seen that live text can be easily integrated into plain text to create a final document that looks nice. We’ve also seen that the actual .Rmd looks differently because of the in-line coding that supports the automatization of the document.\nTo write in-line code you only need to follow this simple structure `r 1+1`. Wrap r inside backtrace brackets, add space followed by the code.\nIf we were to add to the list of movies new entries and we would still want to write that exact paragraph from above then we would simply knit the rmarkdown document and everything would be automated for us, including the counting of how many entries are in the list, what the title of those movies are and how many movies we actually dislike from that list.\nTo do this, open the Excel sheet using Microsoft Excel. Type in one or two new entries following the given structure. Save the Excel and then return to RStudio and knit the .Rmd file. You will notice how in the final document the newly added entries in the movie list are now part of the paragraph.\n\n\n\n\n\n\nTip 3.3: Watch out for structure\n\n\n\nThis automatization only works if the structure of the external source material remains unchanged with updates.\n\n\n\n\n3.0.6 Automated graphs and tables\nOne other benefit of working with automated reports is that tables and graphs are automatically updated with new data. This is rather straightforward - one needs to identify the preferred table format and graph layout, and integrate it in a report. With updated data, the report will automatically update contents of the created table and graphs.\nTo illustrate this, we work with sub-samples from the Stanciu et al. (2017) dataset.\nRemember that we have assigned the sample.sav dataset as dfex dataframe in R previously. This dataframe contains information from N = 100 study participants. See the dataset description in Chapter 1.\nWe subset the dfex dataframe into a much smaller dataframe dfex_1 containing n = 15 study participants and a somewhat larger dataframe dfex_2 containing n = 60 study participants.\n\n# we remove all the labels using the package sjlabelled and mutate\n# as factors columns gen and res\n# this step makes it easier later on to work with plots\n# note that it is not a necessary step in general but only for the sake of \n# simplicity here\ndfex&lt;-dfex %&gt;% sjlabelled::remove_all_labels() %&gt;% \n  mutate(gen=factor(gen),\n         res=factor(res))\n\n# subsamples 15 study participants at random\ntmpdf1&lt;-sample_n(dfex,15)\n# subsample 60 study participants at random\ntmpdf2&lt;-sample_n(dfex,60)\n\n\n3.0.6.1 Graphs\nWe code a simple plot using the package ggplot2 from tidyverse and submit the three dataframes to the code.\n\n\n\n\n\n\n\n\n\n\n\n(a) warmth\n\n\n\n\n\n\n\n\n\n\n\n(b) competence\n\n\n\n\n\n\n\nFigure 3.7: Stereotype\n\n\n\nLet us now create this imaginary scenario. We save the two smaller dfex on the local machine as .sav datasets. This step is usually not necessary when the dataset you want to use gets updated by itself.\n\nhaven::write_sav(tmpdf1,\"data/tmpdf1.sav\")\nhaven::write_sav(tmpdf2,\"data/tmpdf2.sav\")\n\nNow, we’re going to pretend that tmpdf1, tmpdf2 and dfex are all progressive datasets, meaning that the sample size N increases from 15 in tmpdf1 to 100 in dfex. We’re then going to ask for the sample graphs as above in each of the three instances. I won’t cover this step here in detail but this can be easily done independently using this small twist.\n\n# import dataset into one object and then subject this object to the ggplot code\n\n# 1 - imports dataset into object tempdf\ntempdf&lt;-haven::read_sav(\"data/tmpdf1.sav\")\n\n# 2 - applies the ggplot to the dataset\nggplot(tempdf, aes(x=gen, y=wom_warm)) + \n  labs(x=\"Gender\",\n       y=\"Stereotype of warmth\") +\n  geom_boxplot() + \n  theme_light()\n\nggplot(tempdf, aes(x=gen, y=wom_comp)) + \n  labs(x=\"Gender\",\n       y=\"Stereotype of competence\") + \n  geom_boxplot() + \n  theme_light()\n\n\n# 3 - for illustration purposes, repeat step 1 with each \n# of the three datasets (tmpdf1,tmpdf2 and dfex) \n# making sure they are assigned into the same object tempdf. \n# As long as the ggplot code is applied to a dataset with the same structure\n# and variable labels the output will be updated automatically.\n\n\n\n\n\n\n\nFigure 3.8: Automated graphs\n\n\n\nIf all went well, your .Rmd would look similar to mine (see Figure 3.8).\n\n\n3.0.6.2 Tables\nYou can knit a table to your document using knitr, kable and/ or kableExtra packages. Note that there can be differences in whether or not a package returns the desired table layout depending on whether the final knit-ed document is in PDF or HTML format. For the sake of simplicity, we only focus in this short book on final documents in HTML format.\n\ndfmv %&gt;% knitr::kable(caption=\"Simple table using knitr::kable()\",format = \"pipe\")\n\n\nSimple table using knitr::kable()\n\n\n\n\n\n\n\n\n\n\nMovie\nActor\nLike\nWhy\nGrade\nWikilink\n\n\n\n\nJohn Wick\nKeanu Reeves\nYes\nFight scenes\n10\nhttps://en.wikipedia.org/wiki/John_Wick_(film)\n\n\nCall me by your name\nTimothee Chalamet\nYes\nBeautiful love story\n10\nhttps://en.wikipedia.org/wiki/Call_Me_by_Your_Name_(film)\n\n\nTerminator\nArnold Schwarzenegger\nYes\nArnold\n9\nhttps://en.wikipedia.org/wiki/The_Terminator\n\n\n4 months 3 weeks and 2 days\nNA\nYes\nPortrayal of life in communist Romania\n8\nhttps://en.wikipedia.org/wiki/4_Months%2C_3_Weeks_and_2_Days\n\n\n\n\n\nThis is a simple task: Import Excel tables in R and then integrate the contents into a final output document. But, imagine you’d want to manipulate somehow the contents of the source material table and create your own table that can be automatically updated with new input in the source material table.\nFor instance, you might want to create a table of all the movies listed in the source material table where an actor you admire appears in addition to your least liked actor. Say, Keanu Reeves is a liked actor whereas Alec Baldwin might be a least liked actor.\n\n# does some data manipulation to retrieve the required information\ntmptbl&lt;-dfmv %&gt;% \n  filter(Actor %in% c(\"Keanu Reeves\", \"Alec Baldwin\"))\n\n# creates an empty table holder that is our summary table that we'd\n# want to include in the final output document\nextbl&lt;-tibble(\n  \n  like=tmptbl[ tmptbl$Grade &gt;= 8 & tmptbl$Like %in% c(\"Yes\",\"No\"), ]$Like,\n  name=tmptbl[ tmptbl$Grade &gt;= 8 & tmptbl$Like %in% c(\"Yes\",\"No\"), ]$Actor,\n  movie=tmptbl[ tmptbl$Grade &gt;= 8 & tmptbl$Like %in% c(\"Yes\",\"No\"), ]$Movie,\n  wiki=tmptbl[ tmptbl$Grade &gt;= 8 & tmptbl$Like %in% c(\"Yes\",\"No\"), ]$Wikilink\n  \n)\n\nNow we knit the table to the final document. Note that in this particular case no movie by actor Alec Baldwin was listed in the external source material.\n\nextbl %&gt;% knitr::kable(caption=\"Movies graded 8 or more from liked and least like actors\", format=\"pipe\")\n\n\nMovies graded 8 or more from liked and least like actors\n\n\n\n\n\n\n\n\nlike\nname\nmovie\nwiki\n\n\n\n\nYes\nKeanu Reeves\nJohn Wick\nhttps://en.wikipedia.org/wiki/John_Wick_(film)\n\n\n\n\n\nOpen Microsoft Excel movies.xlsx and add one or more movies by actor Alec Baldwin while pretending you dislike the author. Or, you modify the code above and replace the two actors with actors you dislike and like and update the Excel sheet accordingly making sure you maintain the sheet structure.\nThen run the code and you should be able to see updated tables now. The code should like something like in Figure 3.9.\n\n\n\n\n\n\nFigure 3.9: Code for tables in .Rmd",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "autom.html#knit-with-parameters",
    "href": "autom.html#knit-with-parameters",
    "title": "3  Automatization",
    "section": "Knit with parameters",
    "text": "Knit with parameters\nOne way to simplify even more the tasks in automatization of the workflow is to use parameters in knit-ing a final document. More on working with parameters, and how to publish parameterized reports, can be read here.\nParameters are characteristics of the document that are repetitive both throughout the document and along the iteration of various versions of the document.\nSay, you’d want to automatize the writing of a report in each year so the year is a parameter of the report because data, text and tables will have to refer to the in-focus year and thus update the document accordingly.\nSay, you’d want to automatize the analysis of data in ways that tables and graphs are identical but for the grouping variable and year of data collection. Grouping variable and year of data publication are parameters of the document because they repeatedly appear throughout the code.\nWhat makes working with parameters useful is the dynamic and user interface this approach brings to automatization of the work flow. Imagine that you’d want colleagues or superiors to easily have access to repeated reports but they do not posses the coding skills required. You can create a parameterized report for them and they can use a simple user interface (shiny interface that will be covered in details in Chapter 5) to retrieve the documents they are interested in.\n\n3.0.7 Example progression\nWe can transform parts of the .Rmd example into parameters and then knit the final document using a user interface.\nAn intuitive parameter is the name of actors in the Excel sheet movies.xlsx. We have seen that actors Keanu Reeves and Alec Baldwin are liked and not so liked but, most importantly, we have seen that if one adds entries to that external source material the table will be updated. But, now imagine that we want to personalize that list of movies with our very own liked and disliked actors.\nWe could also parameterize which of the stereotype evaluation we’d want to use for graph creation. Remember there were four such variables in the sample.sav dataset, two each for men and women and each gender was evaluated in view of warmth and competence.\n\n\n3.0.8 Changing setup to parameterized report\nTo work with parameters, we first need to define what these are in the yaml of the rmarkdown document.\n\n\n\n\n\n\nFigure 3.10: Modified yaml header for paramtereized reports in .Rmd\n\n\n\nIn Figure 3.10, I highlighted brownish the modification from the previous .Rmd file. Throughout the code lines 5–18, we’ve added two parameters (actor and stereotype) to the rmarkdown document, which are introduced by the yaml attribute params:. These parameters are assigned to objects that can be used in r as seen in the code chunk at lines 36–42.\n\n\n\n\n\n\nFigure 3.11: Modified code for paramterized reports in .Rmd modified\n\n\n\nTo accommodate parameters in the previously written code, we need to make some small modifications to the code as seen in Figure 3.11. Red arrows point to the exact location of parameters in the modified code.\n\n\n\n\n\n\nTip 3.4: Dataframe modification\n\n\n\nNote in Figure 3.10 (or Figure 3.11 for that matter) that we’ve slightly modified the dataframe so that it gets easier to pass it through parameterization. See lines 91–93 where we’ve modified the data structure to long format.\n\n\n\n\n3.0.9 Knitting the document\nknit-ing a document with parameters is as simple as 1-2-3.\n\n\n\n\n\n\nFigure 3.12: Knit with parameters\n\n\n\nOnce the parameterized rmarkdown is built, we can knit it with parameters as show in Figure 3.12.\nNagvigate to the knit button as indicated by the red arrow, open the drop-down menu and from there select “knit with parameters” and following, a window as indicated in Figure 3.12 will appear.\nWe recognize the two parameters we set up above in the yaml header and used throughout the code: “Actor” and “Stereotype evaluation”. Note that these are changeble parameter traits meaning that in the yaml header we can use the attribute label to re-label as per our preference.\nWe have set the attribute input: select in both cases to indicate how the parameter behaves. With input: select, we indicate a list of choices to the parameter from which we can then select only one (case of stereotype) or multiple (case of actor).\n\n\n3.0.10 Something to do by yourself\nGoing back to the “Knit with Parameters” window, all the choices we have pre-programmed will appear here. This also mean that if we want to add something, we can simply add it to the yaml header and the r code will automatically recognize it. Beautiful, clean, and easy.\nPlay with the “Knit with Parameters” a bit. You could, for example, add to the list of actors Timothee Chalamet while deleting one of the other actors. See what happens in the window and in the knit-ed output document.\nTo make things a bit more advanced, open the Microsoft Excel file and add new entries making sure you follow the preset format. Update as desired the choice list in the yaml header and then knit using parameters. What output do you get?\n\n\n3.0.11 Another table example\nOne other way to work with parameterized reports is to code the document such that it creates tables (or anything else for that matter) using a specific dataset. Basically, if the dataset format is identical but contains different N sizes or was collected by different teams or at different times, then parameterized reports can facilitate the creation of repeated reports at a button’s click.\nRemember, we first need to set up the new parameter in the yaml header. Try it yourself following the steps above and then use the code below.\n\n# we assign the parameter sampledf to an object sampledf \n# containing the dataset itself\n# we use paste0() function to integrate the parameter into a string object\n# that tells r where to find the dataset in the .Rproj (the file path) \nsampledf&lt;-paste0(\"data/\",params$sampledf)\nsampledf\n\nabc&lt;-haven::read_sav(sampledf)\nhead(abc) # shows the first lines in the data frame\nnrow(abc) # shows the n size of the data frame\n\n\n# assign parameterized data to an object dataframe\nabc %&gt;% \n  sjlabelled::remove_all_labels() %&gt;% \n  pivot_longer(contains(\"warm\") | contains(\"comp\")) %&gt;% \n  group_by(name) %&gt;% # we group by variable name created previously (background step)\n  summarise(mean=mean(value, na.rm = TRUE), # we use missing remove (na.rm)\n            sd=sd(value, na.rm = TRUE),\n            min=min(value, na.rm = TRUE),\n            max=max(value, na.rm = TRUE))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "autom.html#advanced-resources",
    "href": "autom.html#advanced-resources",
    "title": "3  Automatization",
    "section": "Advanced resources",
    "text": "Advanced resources\nIn this day and age, technology evolves with mind-blowing speeds. This makes it hard to always keep up. Such happens also with the universe of tools available in r.\n\n3.0.12 Towards shiny apps\nParamterized reports use a shiny user interface. We will cover shiny apps in Chapter 5. But for now be as creative as possible.\nFor example, think of a nice graph you could build plotting the age of study participants and their stereotypical evaluation of men and women in terms of warmth and competence. Use the sample.sav or the shorter datasets we created previously.\nCreate a new parameter age having the input: slider attribute. An example of how to do it is given here. Either follow that example or try doing it by yourself.\n\n\n3.0.13 Quarto\nBuilding on rmakrdown et co., the relative quarto is making everything much, much easier. Once the basics of rmarkdown are secured, the transition to quarto is extremely smooth.2\nWhat is quarto and what makes it so advantageous? See for yourself here.\nUse quarto to create presentation slides using the revealjs format. Start from here.\n\n\n\n\n\n\nTip 3.5: Presentations in Quarto\n\n\n\nBuild on the code we’ve covered so far. Write text, dynamic text from data, and incorporate images in your presentation slides created in Quarto.\n\n\n\n\n\nFigure 3.1: Create your first RMarkdown file\nFigure 3.2: RMarkdown document\nFigure 3.3: \nFigure 3.4: Knited bike cover\nFigure 3.5: Example .Rmd file\nFigure 3.6: Live paragraph in .Rmd\nFigure 3.8: Automated graphs\nFigure 3.9: Code for tables in .Rmd\nFigure 3.10: Modified yaml header for paramtereized reports in .Rmd\nFigure 3.11: Modified code for paramterized reports in .Rmd modified\nFigure 3.12: Knit with parameters\n\n\n\nStanciu, A., C. J. Cohrs, K. Hanke, and A. Gavreliuc. 2017. “Within-Culture Variation in the Content of Stereotypes: Application and Development of the Stereotype Content Model in an Eastern European Culture.” The Journal of Social Psychology 157 (5): 611–28. https://doi.org/10.1080/00224545.2016.1262812.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "autom.html#footnotes",
    "href": "autom.html#footnotes",
    "title": "3  Automatization",
    "section": "",
    "text": "RMarkdown is by now old generation. The new generation is quarto, covered in Chapter 4, which keeps all the RMarkdown traits while it simplifies even more the user-experience.↩︎\nWe cover quarto begining with Chapter 4.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Automatization</span>"
    ]
  },
  {
    "objectID": "publish.html",
    "href": "publish.html",
    "title": "4  Self-publish",
    "section": "",
    "text": "Prepping Quarto\nQuarto is a new generation RMarkdown. It retains all the functions of the RMarkdown files from before while it enhances and simplifies several other work flows. Basically, Quarto makes it much much much easier for everyone to create presentations, live documents, websites, books and so on.\nOne can even integrate shiny functionality into Quarto documents. For the present seminar, however, we will introduce shiny apps as separate tools (see Chapter 5).\nSee the official quarto website here.\nTo create content using quarto we need:\n1 - r, which we download and install as described in Chapter 2.\n2 - RStudio, which we download and install as described in Chapter 2.\n3 - Quarto, which can be downloaded here and installed following the indicated steps. Make sure you choose the installation package that suits your operating system.\nAfter you’ve successfully installed r, RStudio, and quarto on your computer, we can start with creating websites and books.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Self-publish</span>"
    ]
  },
  {
    "objectID": "publish.html#website",
    "href": "publish.html#website",
    "title": "4  Self-publish",
    "section": "Website",
    "text": "Website\nIn Chapter 3, we’ve seen that working in Rproj simplifies the work flow including, for example, presetting path dependencies relative to the project folder.\n\n\n\n\n\n\n\n\n\n\n\n(a) Step 1\n\n\n\n\n\n\n\n\n\n\n\n(b) Step 2\n\n\n\n\n\n\n\nFigure 4.1: Steps to creating a Quarto Website project\n\n\n\nWe will use the logic of projects here (and for books) as well. Open RStudio and create a new project Quarto website. See Figure 4.1.\nWhen you create the project, there will be several files created by default: .qmd, .yml, .css as well as a folder “_site”. The files and folder already contain the fundamental structure of a working website.\nTo open this default website on your local computer, navigate inside the folder “_site” and open on your Internet browser the .html1 file index.html.\nEvery website (and online book) has such an index.html file. This file indexes the other files composing the website (or book).\n\n4.0.1 .qmd\n\n\n\n\n\n\nFigure 4.2: Basic structure of a .qmd file\n\n\n\nWe can see the by now familiar structure including the yaml header at lines 1-3, the r code chunk at lines 9-11 and the static text.\n\n\n\n\n\n\nTip 4.1: Quarto markdown\n\n\n\n.qmd is the new generation .Rmd\n\n\nWe can also see the Render button on the upper bar where the knit button would be in an old generation RMarkdown file.\nWe can edit this file in virtually identical manner to any other .Rmd file. I say virtually identically because the .qmd file comes with extra benefits making it easier to control the formatting of content on the page. One can easily implement some .html features such as div using the :::{} blocks2. Read more on the basics of .qmd here.\n\n\n\n\n\n\nFigure 4.3: Two columns using div blocks\n\n\n\nSee for example how a two columned format looks like in Figure 4.3. Include it in your .qmd file and then render it. See how it looks.\n\n\n4.0.2 .yml\n\n\n\n\n\n\nFigure 4.4: Elements of the .yml file\n\n\n\nThree elements are observable when opening the default .yml file: project, website, and format. See Figure 4.4.\nFirst, the element project defines the type of the project you work one. It can be a website as well as a book.\nSecond, the element website defines attributes of the website. In Figure 4.4 we can see attributes “title” and “navbar”. title allows us to give a title to the website. navbar is short for navigation bar. Let us look a bit closer at it.\nInside navbar there is an element left which defines the positioning of the navigation bar. It can also be right, for example. On the navbar we then place the individual pages - which are none other the html renditions of the .qmd files. We see two ways to place these individual pages.\nOne is where we give a custom label to the page: see lines 8 and 9. Another where we use the default label that derives from the title of the individual page (remember that each RMarkdown file has a yaml header and so has every .qmd file).\n\n\n\n\n\n\nTip 4.2: Listing all the individual pages\n\n\n\nRemember to list in the navbar all the individual pages you’d like to be rendered in the final website. Otherwise, the website will not contain them!\n\n\nThird, the element format allows us to format the website overall including, for example, a theme, css (cascading style sheets) or even add a table of contents (toc). theme, css and toc and attributes of the html document. Remember from Chapter 3 the concept of parameters? Well, that is pretty much the logic here as well - these three are parameters of the html file that we can modify according to our needs. This means that there are multiple themes we can choose from and we can write our very own .css style. We may decide to include a toc or not.\n\n\n\n\n\n\nTip 4.3: Further html themes\n\n\n\nSelect from this list of quarto html themes the one you’d prefer\n\n\n\n\n4.0.3 .css\nThe default .css file is empty. I would say that css is rather advanced so I won’t cover it here. Typically, one can create custom css styles for their website or can download templates from the Internet. Be aware however what you download and from where.\nFor the purpose of this seminar the default .css is more than enough.\n\n\n4.0.4 _site folder\nThis folder is created by default. It is the containing folder of the rendered html files and other elements required for the final website.\nFor the purpose of this seminar, this folder is important for us because it contains the index.html file. By opening it on our browser, we can inspect locally the rendered website.\n\n\n4.0.5 Deployment\nOnce you’ve created and locally inspected your website, the next step is to deploy it (publish) it online. Remember from Chapter 1 that we would need an online repository like GitHub and, most importantly, to have an open and encrypted channel connecting the local machine and the server.\nOne other way to publish your site is through quartopub.com. Open an account on quartopub.com. We will deploy the website using these two ways: GitHub and quartopub.com. I will describe a bit why you might want to choose one or the other.\n\n4.0.5.1 Via quartopub\nThis is a very simple way to deploy your website online. It is integrated seamlessly with quarto so you only need two lines of code in the Terminal. Really.\nFirst, we need to render the website. To link together all the files that we’ve created/ edited included the .qmd, .yml and .css.\nCopy the line below into the Terminal of your website project and run it.\n\nquarto render\n\nNext, we can publish it via quartopub provided that we have opened an account.\nCopy the line below into the Terminal of your website project and run it.\n\nquarto publish quarto-pub\n\nYou will notice some code running and finally that in the project folder there is a new yml file created _publish.yml. If you open it, you will notice among other the URL to your newly and publicly available website.\nWith this approach you deploy the website on a remote server and your files remain available for editing only locally on your machine. You also need to make sure that you render the website after each modification to files making up the website.\nThe created example is published through quarto pub here.\n\n\n4.0.5.2 Via GitHub Pages\nIn some situations you might want to deploy the website and upload the files comprising the website on a remote repository. This means that your files can be made publicly available for other to clone them or they are available to you in the “cloud”. The website itself is deployed and everybody can access it but in addition everyone can have access to the files that create the website.\nThis approach might be preferable when you maintain a website as a group. Or when you create a fancy website together with colleagues from across the globe.\nI wrote a step-by-step guide explanation for older generation RMarkdown. This can be accessed here.\nReturning to Quarto Website and assuming that a GitHub account has been created, you may follow the steps here. A summary of the steps are provided below:\n1 - Create a Quarto Website project on your local machine.\n2 - Make the folder containing the quarto website a git repository3.\n\ngit init\n\n3 - Create an empty repository on your GitHub account. Then, connect the local repository to the newly created online repository.\n\nremote add origin git@github.com:{your github user}/{your repository where the website will be hosted}.git\n\n4 - We will deploy the website by rendering it to a sub-folder docs. To do this we need to modify the _quarto.yml document. Open the .yml file, copy the following line and paste it as a sub-element to “project”. This new line should be intended and be aligned with the “type: website” element! Save and close the .yml file.\n\noutput-dir: docs\n\n5 - Create a .nojekyll file to the repository. Explanation is given here. Go to the Terminal of the website project and run the code line:\nMac/ Linux\n\ntouch .nojekyll\n\nWindows\n\ncopy NUL .nojekyll\n\n6 - Render the website. Note that the website will be automatically rendered in the sub-folder docs.\n\nquarto render\n\n7 - We push everything to our GitHub repository.\n\ngit add .\ngit commit -m \"Push website\"\ngit push\n\n8 - Check that the push was successful.\n\n\n\n\n\n\nFigure 4.5: Contents of the created GitHub repository\n\n\n\nGo on your GitHub account, open the repository and it should look something like Figure 4.5.\n9 - Setup GitHub to “read” the website from the sub-folder docs.\n\n\n\n\n\n\nFigure 4.6: Setup for deployment from main/docs\n\n\n\nNavigate to Settings/ Pages and change under “Build and deployment” the branch and folder according to Figure 4.6. Save changes.\n10 - A visit site panel will appear shortly, after the website has been rendered and created, like in Figure 4.6. This may take between a few seconds and a couple of minutes depending on the server availability. Refresh the page and the website is now publicly accessible.\n11 - Now you can repeat steps 6 through 8 every time you edited or modified contents for your website. The website itself will be updated automatically (might take a couple of minutes though).\nThe created example is published via GitHub pages here4.\n\n\n\n\n\n\nTip 4.4: Custom domains\n\n\n\nYou can publish your website (or book, as we will see in the next section) on a custom domain. For this you’d need to pay a monthly or yearly fee.\nSee for details this ultra-brief guide I wrote some time ago but still remains valid.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Self-publish</span>"
    ]
  },
  {
    "objectID": "publish.html#online-book",
    "href": "publish.html#online-book",
    "title": "4  Self-publish",
    "section": "Online book",
    "text": "Online book\nTo start with Quarto Books, we should first create such a project. The steps are similar to creating a Quarto Website.5\n\n\n\n\n\n\n\n\n\n\n\n(a) Step 1\n\n\n\n\n\n\n\n\n\n\n\n(b) Step 2\n\n\n\n\n\n\n\nFigure 4.7: Steps to creating a Quarto Book project\n\n\n\nWhen you create the project (see Figure 4.7), there will be several files created by default: .qmd, .yml, .bib as well as a folder “_book”. The files and folder already contain the fundamental structure of a renderable book.\nTo open this default book on your local computer, navigate inside the folder “_book” and open on your Internet browser the index.html.\n\n4.0.6 .qmd\nSee sub-section on .qmd for creating websites.\nIf you feel comfortable, create some content for the book, for example, add a chapter about yourself.\n\n\n4.0.7 .yml\nThis file type is identical to the one for creating websites. But, there are different attributes addressed! See Figure 4.8.\n\n\n\n\n\n\nFigure 4.8: Attributes of the .yml file for books\n\n\n\nFirst to notice, is that now the project we create is type: book. We have learned from the website deployment section that, if we wanted, we could deploy the book via GitHub Pages. That is why I already added the output-dir: docs in Figure 4.8.\nLines 5 through 13 hold attributes of the book. Remember that for the website, we had specified attributes for website. So, at line 4 in Figure 4.4 we had website: followed by attributes whereas at line 5 in Figure 4.8 we have book: followed by several attributes.\nIn our example, we have four book attributes including a title, author, publication date and chapters. For a comprehensive list of book attributes see here.\n\n\n\n\n\n\nTip 4.5: List all the chapters!\n\n\n\nRemember to list under chapters: all the .qmd chapters you’d want to render to the final book. Otherwise these are not included. Note also that the order of chapters is defined here.\n\n\nAt line 15, we see the bibliography: entry. We will cover this shortly. But, this element is relevant for books and publishable manuscripts alike. It renders to the final document a .bib file that contains references.\nAt lines 17 through 21, we see the format: element, which is similar to website creation. Next to the familiar .html format, we now see also .pdf format. This means that we can render the book both in html and pdf formats! Other formats are likewise possible, for instance, .epub which are for e-readers.\n\n\n\n\n\n\nTip 4.6: PDF of your book\n\n\n\nYou may inspect the PDF version of your book by navigating inside the “_book” (or “docs”, depending on the output-directory indicated in the .yml file) folder provided, of course, that you first rendered the book using, for example, the code line quarto render.\n\n\n\n\n4.0.8 .bib\nThe .bib file format is otherwise said what makes it possible to integrate citations to your book or publishable documents as part of the workflow. .bib files are a type of plain text files (no hyperlinks or enhanced fields that are typical in standard text editors like Microsoft Word).\n\n\n\n\n\n\nFigure 4.9: Example of reference in .bib format\n\n\n\nRead more on using .bib reference files here.\nMany journals offer the possibility to download a .bib citation of their articles. For example, navigate to this article Conner and Armitage (1998) published at Journal of Applied Social Psychology (open access). Identify the TOOLS button, press it, and navigate to Export Citation where you can download a BibTex (.bib) citation ready to be incorporated in your reference file.\nOne can use online tools for transforming plain text citations into .bib citation format. For example, this converter. Use this if you have a plain text list of references and you’d want them transferred into a .bib file.\nSo, in our case, as shown in Figure 4.8 at line 15, we specify bibliography: references.bib meaning that the bibliography for the book should be constructed through rendering from the file references.bib.\n\n\n4.0.9 Deployment\n\n4.0.9.1 Via quartopub\nBook deployment is almost identical with the deployment of websites.\nThe easiest option is to deploy through quarto pub. To do this, we only need to do the following:\n1 - Make sure we have opened an account on quarto.com\n2 - render the book using the line code below (identical to the one used for websites)\n\nquarto render\n\nIt may take a couple of seconds until the book is rendered. And, if it is the first time you render a qurto book it may take a bit until the necessary dependencies are installed.\n3 - Publish the book using one line of code.\n\nquarto publish quarto-pub\n\nThe example book was published online through quarto.pub here.\n\n\n4.0.9.2 Via GitHub Pages\nThe example book was published online via GitHub pages here. Similar to the website example, the book is attributed to my personal website.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Self-publish</span>"
    ]
  },
  {
    "objectID": "publish.html#advanced-resources",
    "href": "publish.html#advanced-resources",
    "title": "4  Self-publish",
    "section": "Advanced resources",
    "text": "Advanced resources\nThere are some alternatives out there, for example:\n\nTo create a blog using the blogdown package. See a step-by-step guide by Shilaan Alzahawi.\nTo create a website using the distill package. See a guide by Sally A.M. Hogenboom.\nA more comprenesive guide to creating a website using r and RStudio is provided in this eBook by Danny Morris.\nA different (using older generation RMarkdown) way to self-publish books online using r package bookdown. See this guide by Yihui Xie who basically (co-)created all of this that we are covering throughout the seminar.\n\nLast, but not least. With quarto, one can publish even articles. That is right, one can write using r publishable manuscripts. Start here and see here the journals that already support manuscript submission of quarto templates. This is the cherry on top of the cake in view open and transparent science.\n\n\n\nFigure 4.1 (a): Step 1\nFigure 4.1 (b): Step 2\nFigure 4.2: Basic structure of a .qmd file\nFigure 4.3: Two columns using div blocks\nFigure 4.4: Elements of the .yml file\nFigure 4.5: Contents of the created GitHub repository\nFigure 4.6: Setup for deployment from main/docs\nFigure 4.7 (a): Step 1\nFigure 4.7 (b): Step 2\nFigure 4.8: Attributes of the .yml file for books\nFigure 4.9: Example of reference in .bib format\n\n\n\nConner, M., and Christopher J. Armitage. 1998. “Extending the Theory of Planned Behavior: A Review and Avenues for Further Research.” Journal of Applied Social Psychology 28 (15): 1429–64. https://doi.org/10.1111/j.1559-1816.1998.tb01685.x.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Self-publish</span>"
    ]
  },
  {
    "objectID": "publish.html#footnotes",
    "href": "publish.html#footnotes",
    "title": "4  Self-publish",
    "section": "",
    "text": ".html files are specific types of file that are used online↩︎\nSome div blocks require four : instead of three, for example ::::{}. Additional : indicate therefore upper levels of div code embededdness.↩︎\nIn Chapter 1 we covered the set up of GitHub and repositories including installing a suite of code. Make sure that is done before attempting to create the folder a git repository.↩︎\nNote that I am using a custom domain at the root of which is my personal website. In your case it would have a slightly different domain but the website itself will look similar to the example shown.↩︎\nAs a matter of fact, you might have noticed by now that creating an R project is this simple. You can follow these steps also when creating for example a presentation or a publishable manuscript.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Self-publish</span>"
    ]
  },
  {
    "objectID": "apps.html",
    "href": "apps.html",
    "title": "5  Shiny apps",
    "section": "",
    "text": "The set-up\nFigure 5.1 should by now be a familiar routine: We create an R project that has a default working app. Once you’ve created the project, you will note only one file: app.R (next to the .Rproj extension, of course).\nThe .R file format is an r script file format. Meaning, that you can write r code, save it and even run it without having to transfer the code to the console. Remember that in RMarkdown and quarto documents, we worked with r code chunks. Well, the .R script files are much like a gianormous code chunk.\nRemember the dataset Stanciu et al. (2017) introduced in Chapter 1? We will use it in creating our very own shiny app.\nIf everything went well, we should have the shiny package already installed from Chapter 1. But, if you haven’t done so yet, or are unsure about it, now is a good time to install this package.\ninstall.packages(\"shiny\")\nlibrary(shiny)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#the-set-up",
    "href": "apps.html#the-set-up",
    "title": "5  Shiny apps",
    "section": "",
    "text": "(a) Step 1\n\n\n\n\n\n\n\n\n\n\n\n(b) Step 2\n\n\n\n\n\n\n\nFigure 5.1: Steps to creating a Shiny Application project\n\n\n\n\n\n\n\n\n\n\n\n\nTip 5.2: R script files\n\n\n\nNote that r script files can hold only basic code meaning that features from RMarkdown and quarto are not available. If you’d like to integrate HTML or other languages, that is possible, but requires appropriate integration which we do not cover here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#r-script-files-1",
    "href": "apps.html#r-script-files-1",
    "title": "5  Shiny apps",
    "section": "R script files",
    "text": "R script files\n.R script files can be very useful not only for shiny apps but also for websites or books. Writing code in such file format can keep the work environment neat and tidy. Also, you might want to use script files when you know in advance that you have repetitive code (e.g., functions) that you use across several of your projects.\nOne example where I personally apply this work strategy is when writing my own functions (see Chapter 2). Instead of writing a function each time I would need it, I include all functions I create into an .R script file which I then copy-paste to all my projects. Other strategies are possible, for example, install all packages in a separate script file or divide the work flow in programming into several steps - data import, data cleaning, data manipulation, data analysis, and data ready to report.\nWhen working with code stored in separate script files we need to call these into the main document, for instance, in an RMarkdown, quarto or shiny app.\nThis is easily done with the function source(\"{yourrscript here}\"). Make sure that the path dependency is correct and that the script is wrapped around \" \".\n\n\n\n\n\n\nTip 5.3: Calling R data files\n\n\n\nWhen we work with data saved in an R format such as .Rds and .Rdata, we can call this dataframe using the function load(\"{your .Rdata dataframe here}\"). Remember the path dependencies and the \" \"!\n\n\nBefore we start working on the shiny app let us save the data (Stanciu et al. 2017) into an .Rdata format. This makes it somewhat easier to import the dataframe in the shiny app code, as it is already in an r format.\nBuilding on the code written in Chapter 3, we save to an .Rdata file format.\n\n# imports data in SPSS .sav format\ndfex&lt;-haven::read_sav(\"data/sample.sav\")\n\n# saves R object dfex into an .Rdata format \n# which we load into the shiny app shortly\nsave(dfex,file=\"data/sample.Rdata\")\n\nIn Chapter 2 we wrote a basic function to add a constant to all numeric columns to a data frame. We can copy this function into an .R script so that we have access to it in writing our first shiny app.\nCreate a new .R script file by navigating to File/ New File/ R Script. It will open an empty untitled script file. Copy the function as is into this script file.\n\nfunc1&lt;-function(df,n){\n  \n  tmp &lt;- Filter(is.numeric, df) # we first filter the dataframe for numeric columns\n  \n  tmp + n # we then add the constant to all the numeric columns\n}\n\n\n\n\n\n\n\nTip 5.4: Packes for r scripts\n\n\n\nNote that if you write custom scripts and store them inside r script files, you’d need to make sure that the required packages are called inside that script file. Use the install.packages() or library() commands as described in Chapter 2.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#shiny-apps-structure",
    "href": "apps.html#shiny-apps-structure",
    "title": "5  Shiny apps",
    "section": "Shiny apps structure",
    "text": "Shiny apps structure\nWhat makes shiny apps powerful and at the same time a bit tricky to program is the structure. Shiny apps have a user interface (UI) that is wrapped around code that runs in the background on a server. When programming a shiny app therefore we need to program both the design (UI) and the code that runs on the server (server).\nThe UI part makes a shiny app attractive to the audience and, if programmed right, can engage the audience in an interactive and dynamic manner. Programming the UI part requires a bit of orientation toward the audience for which the app is designed. What are the minimum skills required to operate the app? What theoretical and practical expertise is expected for the audience to intuitively navigate the app? Read more on user interface in general on the Wikipedia page.\nThe server part makes a shiny app, well, work. Here is where code is written to import, clean, manipulate and analyse data, metadata and all sorts of other things. One way that I find helpful to think of the server part is to see it as the old-school R coding on my local machine. When you use r for data analysis, for example, you use this programming language in the console which then you run resulting in some form of output. Well, this means technically that you interact with your computational machine (CPU, for example) through the r programming language. This very principle applies also for writing code for the server for shiny apps.\nThis distinction is less intuitive when we run the shiny app on the local machine. But, this distinction between UI and server becomes crucial when we deploy the app on online repositories, as we will see shortly. By deploying the app code structured into UI and server, we tell the respective servers how to read our code.\nSo, long story short, both the UI and server segments of a shiny app code has its own pre-defined role and it is crucial for the well functioning of the app that this structure is maintained. Otherwise the app breaks.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#code-for-ui",
    "href": "apps.html#code-for-ui",
    "title": "5  Shiny apps",
    "section": "Code for UI",
    "text": "Code for UI\nThis will not be a comprehensive code at all. But, it should offer sufficient hands-on tips on how to start building your UI for your first shiny app.\nOne thing to keep on the back of your mind is that in the UI part we need to refer to objects from the server part. If we do not call objects from the server in the UI part properly, the app might still work but the audience will not have access to it.\n\n\n\n\n\n\nTip 5.5: Commas and brackets!\n\n\n\nMake sure that you always use commas and close the brackets appropriately. Otherwise, the design might not look as intended or the entire code might break even.\n\n\nMy recommendation is to take some time to decide what do you want to include in the app and what do you need for your audience. For example, do you want the audience to view plots or tables, and if yes, do you want these to be interactive? If that is the case, what code do you need to write on the server part and what is the final r object that you’d want to be displayed for the audience via the UI?\nSo, for me at least, writing a shiny app is a bit of a forth and back between the UI and server code.\n\n5.0.1 Layout\n\n\n\n\n\n\n\n\n\n(a) Basic panels of a shiny app.\n\n\n\n\n\n\n\n\n\n(b) Corresponding code in the UI.\n\n\n\n\n\nFigure 5.2: UI code and corresponding shiny outcome\n\n\n\nsidebarLayout(): Inside this function we define the content that will be displayed on the side of the app window. See red panel of Figure 5.2 (a) and the corresponding red panel in Figure 5.2 (b). One can also add elements to the layout of this panel. For example try out the code below and see what happens.\n\n# copy and paste this code line as the first argument inside the\n# sidebarLayout() function followed by a comma\n# I cannot stress this enough: Commas are super super important\n# so do not forget them\n\nposition = \"right\"\n\nsidebarPanel(): This is wrapped inside the sidebarLayout() because it is just one element of several that can be placed on the sidebarLayout of the app.\nThe attributes defined here are fed into the code on the server, so make sure you chose the appropriate user input type.\nmainPanel(): This contains the output, be it plain text, live text, tables or figures. If in the sidebarPanel() you define the user input attributes, in the mainPanel() you simply call the objects computed on the server and programm how exactly will they be displayed. See in blue Figure 5.2 (a) and the corresponding code in blue inside the UI Figure 5.2 (b).\n\n\n5.0.2 Input types\nInside the sidebarPanel() we can define the kind of user input we expect our audience to play with. That is – remember parameterized reports from Chapter 3 – what are the parameters that users can interact with. There are a couple of input types, for example, slider input on a continuous pre-defined numeric range, select from a pre-defined list, check if TRUE or FALSE, and a numeric only text field.\nsliderInput(): This is given as an example in the default shiny app that comes pre-set when creating a shiny app project. It is a slider input type. Observable are five attributes:\n\nLabel of the input \"bins\" which is a reference label for the code\nLabel of the input displayed to users (\"Number of bins:\"). Note that this is different than input label above and serves only the function of informing the user. The input label above serves the function of cross-reference in code writing.\nmin and max define the minimum and maximum of the numeric range of the slider.\nvalue defines the default value of the slider which is displayed every time the app is called.\n\nselectInput(): This is a select from a pre-defined list input type. In the basic form, it requires three attributes:\n\nLabel of input for cross-referencing in the code.\nLabel of input for display for the app users.\nValues of the pre-defined list. Note that these should be places inside a list, which has this basic structure:\n\n\nc(\"{NAME 1 TO BE DISPLAYED}\" = \"{value 1 for code cross-referencing}\",\n\"{NAME 2 TO BE DISPLAYED}\" = \"{value 2 for code cross-referencing}\"...)\n\nIt may look like this (code from Witte and Stanciu (2023)).\n\nselectInput(\"hov\", \n          \"Choice: \",\n        c(\"all\",\n          \"Openness to change\" = \"och\",\n          \"Conservation\" = \"con\",\n          \"Self Transcendence\" = \"str\",\n          \"Self Enhancement\" = \"sen\")\n                     )#closes selectInput\n\ncheckboxInput(): This is a yes/ no logical input type. Ideally, you always define at least three atributes:\n\nLabel of input for cross-referencing in the code.\nLabel of input for display for the app users.\nvalue is true (value = T) or false (value = F).\n\nIt may look like this (code from Witte and Stanciu (2023)).\n\ncheckboxInput(\"p1.ess\",\"Distribution\", value = F)\n\nnumericInput(): This an input type that allows the user to type in numeric values within a pre-defined range with a pre-defined increment value. One can define the following:\n\nLabel of input for cross-referencing in the code.\nLabel of input for display for the app users.\nvalue is the default value show every time the app is opened.\nmin and max define the range of possible values within which the user can choose to enter from. Note that this range is not visible to the user but it is a by-design-limitation. An error is shown or simply the input is not validated if the user enters a value outside this pre-defined range.\nstep defines the increment value. It can be a full integral number or anything inbetween.\n\nIt may look like this (code from Witte and Stanciu (2023)).\n\n numericInput(\"n\",\n                                  label = \"Sample size\",\n                                  value = 20,\n                                  min = 20,\n                                  max = 1000,\n                                  step = 1)\n\n\n\n5.0.3 Conditional panels\nThere might be situations where you’d want to create a conditional user interface. This means that the UI experience can, at some pre-defined parts, be conditional on user input. For instance, for the app Quantum Social Science, I created a UI dependent on type of analysis: choice. There are three choices the user can select: Simulations, Survey data or Experimental data (which is still under construction). Depending on the user choice at this stage, the user has different options to choose from - either interact with simulated data or with secondary data.\nIt may look like (code from Witte and Stanciu (2023)).\n\n  conditionalPanel( \n            condition= \"input.type=='Simulations'\",\n... # the code continues here with input values\n\nconditionalPanel(): Wrapped inside one can code the UI conditional on an input defined at a previous stage. Let us pay a closer look at the example above:\ncondition = \"input.type=='Simulations'\":\n\ncondition = introduces the condition that needs to hold for the contents of the rest of conditionalPanel to be activated.\n\"input.type=='Simulations'\" is the condition itself which is to be read as follows: if the input of input object “type” is identical to “Simulations”, then the subsequent contents are activated. See Figure 5.3.\n\n\n\n\n\n\n\nFigure 5.3: Exerpt from UI code of Witte and Stanciu (2023)\n\n\n\n\n\n5.0.4 Tabset\nThere can be situations where it is helpful to organize output into separate panels – similar logic to having several tabs open on your web browser.\nThe app Predicted as observed created by Julian Kohne for the paper Witte, Stanciu, and Zenker (2022) nicely uses this feature.\nIn the mainPanel() the “Abstract” of the paper, followed by “Check assumptions”, the calculation of the “Similarity Index” and display of the “Similarity Interval”, and, finally, “Recommendations” are organized neatly into tabs. The user can navigate these tabs knowing the kind of content to expect.\ntabsetPanel(): defines the overall structure within which multiple panels can be placed.\ntabPanel(): defines the content be placed inside a tab. This is coded inside tabsetPabel()!\nIt may look something like this.\n\ntabsetPabel(\n  tabPanel1(\"label 1 for display to user\", {content 1 here}),\n  tabPanel2(\"label 2 for display to user\", {content 2 here})\n)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#code-for-server",
    "href": "apps.html#code-for-server",
    "title": "5  Shiny apps",
    "section": "Code for server",
    "text": "Code for server\nThe code for the server is a custom function, a gianormous custom function! Like any custom functions (see Chapter 2), there is a structure to it, namely function(){}.\nThe server function takes two arguments, namely input and output.\ninput signals what comes from the UI interface. That is, what the user of the app is inputing via the UI.\noutput signals what goes from the server to the UI. That is, what the user views as a result of interacting with the app.\n\n5.0.5 Reactive objects\nThe simplest way to think of reactive objects is to see them as plain old-school R code wrapped inside an object that the server needs to compute. It is reactive, because the server has to first compute the reactive object before performing any tasks that call on such an object.\nIn r code written for computation on the local machine it would be called simply an r object.\nOn the server, however, code is computed only when needed which makes objects created on the server reactive to code that requires them. They react if you poke them. Otherwise, they sleep.\n\n\n\n\n\n\nTip 5.6: Mind the brackets\n\n\n\nThis is one of those ultra small details that took me days to figure out. When you create a reactive object, remember to always call it as such. It is an r object all right, but it looks like a function: reactiveobject().\n\n\nA reactive object, like all objects coded for the server, need to be wrapped in a specific function, otherwise the server will not recognize it as such.\n\n\n\n\n\n\nTip 5.7: Server code\n\n\n\nCode for the server – whether it is reactive, input or output objects – needs to be written inside ({YOUR SERVER CODE HERE}). It is a specific code chunk for the server. Its logic is similar to the code chunk introduced in Chapter 3 – it is a field recognized by the server as code to be computed.\n\n\nOnce a reactive object was coded following the code structure introduce in Tip 5.7, the reactive object itself can be called inside other code on the server following the structure presented in Tip 5.6.\n\n\n5.0.6 Input objects\nTechnically speaking, input objects are reactive objects. But, I discuss them separately because these feed user input to the code.\nThis can be recognized and done by adding the prefix input$ when calling user input.\n\n\n\n\n\n\n\n\n\n\n\n(a) Example code reactive and input object.\n\n\n\n\n\n\n\n\n\n\n\n(b) Corresponding UI code for input objects.\n\n\n\n\n\n\n\nFigure 5.4: Code example for reactive objects with user input\n\n\n\nIn the code example from Witte, Stanciu, and Zenker (2022) (see Figure 5.4 (a)), a reactive object tmp.df is coded at lines 385 – 395.\nThis reactive object happens to be using user input information as indicated at lines 387 – 390.\nTo illustrate the correspondence between UI and the server, see in Figure 5.4 (b) the user defined object n at lines 95 – 100 and the user defined object m0 at lines 102 – 107.\n\n\n5.0.7 Output objects\nOutput objects are the output that we want to be displayed on the user interface. This means that we have to call it as such and indicate the position where we want it displayed.\nIdeally, we have already coded the display position and display characteristics in the UI code.\nOn the server, we need to indicate the object corresponding to the UI code accordingly. When we feed user input to the server code we write the prefix input${USER INPUT}. Well, when we want an object displyed on the user interface we write the prefix output${corresponding label in the UI code}.\nNote the dollar sign $!\n\n\n\n\n\n\n\n\n\n\n\n(a) UI code and corresponding server code for output object.\n\n\n\n\n\n\n\n\n\n\n\n(b) Corresponding plot display in the user interface.\n\n\n\n\n\n\n\nFigure 5.5: Shiny app full circle: ui, server and user experience\n\n\n\nIn Figure 5.5 (a), we see at lines 36 – 38 (red field) the UI code for object distPlot to be displayed. At lines, 45 – 54 (blue field), we see the server code for this object. Finally, in Figure 5.5 (b) (blue field), we see the output plot displayed for user experience.\n\n\n\n\n\n\nTip 5.8: Output objects need adequate functions\n\n\n\nWhen writing output objects, these need to be wrapped inside designated code chunks – for plots or tables or text. See this official cheat sheet.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#run-the-app-locally",
    "href": "apps.html#run-the-app-locally",
    "title": "5  Shiny apps",
    "section": "Run the app locally",
    "text": "Run the app locally\nRunning the app locally is as simple as pressing the button Run App on the bar – see for instance Figure 5.2 (b).\nNote however that this is in fact calling a function written inside the app.R script.\nThis function is shinyApp(ui = ui,server = server). The shinyApp() function takes two arguments ui and server which we define separately, as indicated above.\nA new window will open. You might note two things in the console:\n\nThe console is busy with the app, as indicated by the STOP symbol.\nThe text in the console Listening on {an IP address}.\n\nThese two things indicate that the app is running and that the console cannot be used for other purposes. It also means that the app is automatically updated if you are to modify the code, UI or server. It also means that your local machine acts as the server in this case.\nThe moment you close the app, the console becomes available once more.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#deployment",
    "href": "apps.html#deployment",
    "title": "5  Shiny apps",
    "section": "Deployment",
    "text": "Deployment\nTo deploy the app, we would need a dedicated server and, of course, an access account on that server. One efficient and smooth way to deploy a shiny app online is to use the dedicated server shinyapps.io. It is a free service maintained by the same community behind RStudio – posit.co.\nTo start with, open an account on shinyapps.io. Once you have an account, we can turn back to our app that we’ve coded in RStudio.\n\n\n\n\n\n\nFigure 5.6: Steps to shiny app deployment on external server.\n\n\n\nNext to the button Run App there is another button called Publish the application or document. Click on it and follow the steps as indicated. Note that in Figure 5.6, the app has already been deployed so there is a connection with the external server made. If you publish an app for the first time, you will only see the option Publish Website.... Select from the options shinyapps.io and follow the instructions. In a matter of a few secods your app will be online!4\n\n\n\n\n\n\nTip 5.9: Select your files to deploy\n\n\n\nNot all files are needed for the final app to function. When you deploy the app, select those files from your local repository that the app actually needs to function. By doing this, you make sure that the server is not filled with junk. After all, your free shinyapps.io account has limited space.\n\n\nThe illustrative example is deployed online here. See also sub-section below.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#optional-push-to-github",
    "href": "apps.html#optional-push-to-github",
    "title": "5  Shiny apps",
    "section": "(Optional) Push to GitHub",
    "text": "(Optional) Push to GitHub\nOne further thing we might want to do is to push the script files to GitHub as discussed in Chapter 4.\nTry doing that yourself. I pushed my script files on a public GitHub repository that can be accessed here5.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#progress-illustrative-example",
    "href": "apps.html#progress-illustrative-example",
    "title": "5  Shiny apps",
    "section": "Progress illustrative example",
    "text": "Progress illustrative example\nBelow is the entire code for the illustrative example that was transformed from a parameterized report into a shiny app.\nYou can try to replicate it by yourself and compare it with mine. Or copy paste it directly into a app.R script and run it. The choice is yours.\n\n### calls r script files\nsource(\"functions.R\")\n\n### loads data\nload(\"data/sample.Rdata\")\n\n### imports libraries\nlibrary(shiny)\n\nr &lt;- getOption(\"repos\")\nr[\"CRAN\"] &lt;-\"https://cloud.r-project.org/\"\noptions(repos=r)\n\n# install.packages(\"pacman\")\n\n# pacman::p_load(tidyverse,readxl,haven,sjlabelled,kable,kableExtra)\n\n#### shiny app starts here ###\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Illustrative example\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(position = \"left\",\n                  \n        sidebarPanel(\n          \n          # actor input\n          selectInput(\"actor\",\n                      label=\"Choose an actor:\",\n                      c(\"Keanu Reeves\",\n                        \"Alec Baldwin\",\n                        \"Arnold Schwarzenegger\",\n                        \"Timothee Chalamet\",\n                        \"Anamaria Marinca\"),\n                      multiple = TRUE),\n          \n          # stereotype input  \n          selectInput(\"stereotype\",\n                        label=\"Stereotype dimension:\",\n                        c(\"Warmth women\" = \"wom_warm\",\n                                  \"Competence women\" = \"wom_comp\",\n                                  \"Warmth men\" = \"men_warm\",\n                                  \"Competence men\" = \"men_comp\"))\n            \n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n          \n          h3(\"Output displayed here\",),\n          # start tabset Panel\n          tabsetPanel(\n            \n            # tab 1\n            tabPanel(\"Actors\",\n                     \n                     tags$p(HTML(paste(\"A table is generated based on the actors chosen on the side panel..\", sep = \"\")) ),        \n                     \n                     DT::dataTableOutput(\"act\") ),\n            \n            # tab 2\n            tabPanel(\"Stereotypes\",\n                     \n                     tags$p(HTML(paste(\"A plote is generated based on the variable chosen on the side panel..\", sep = \"\")) ),\n                     \n                     plotOutput(\"st\") )\n            \n          ) # close tabset Panel\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n  ####### -- imports and prepares data from here \n  \n  # reactive object\n  # data from Stanciu et al. 2017\n  \n  tempdf &lt;- reactive({\n    \n    choice=input$stereotype\n    \n    dfex %&gt;% \n      sjlabelled::remove_all_labels() %&gt;% \n      pivot_longer(contains(\"warm\") | contains(\"comp\")) %&gt;% \n      filter(name %in% choice)\n  \n  })\n  \n  # reactive object\n  # meta data movies\n  movietmp&lt;- reactive({\n    dfmv&lt;-readxl::read_excel(\"mat/movies.xlsx\",1) %&gt;% \n      filter(Actor %in% input$actor)\n    \n  })\n  \n    #### -- generates output objects from here\n  \n  # generate ggplot\n  plottmp&lt;- reactive({\n    \n    ## ggplot code\n    (input$plot_type == \"ggplot2\")\n    \n    ggplot(tempdf(), aes(x=factor(gen),y=value)) +\n      labs(title=paste0(\"Evaluation based on \", input$stereotype), \n           x=\"Gender\",\n           y=paste0(\"Stereotype of \", input$stereotype)) +\n      geom_boxplot() + \n      theme_light()\n  })\n  \n  ##### -- code for output from here\n  \n  # render plot for user \n  output$st &lt;- renderPlot({\n   \n    plottmp()\n  })\n  \n  output$act &lt;- DT::renderDataTable({\n    \n    movietmp()\n  })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nNote however that you’d still need to create all the external scripts and r data files.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#advanced-resources",
    "href": "apps.html#advanced-resources",
    "title": "5  Shiny apps",
    "section": "Advanced resources",
    "text": "Advanced resources\nIf you really really like shiny apps and want to master them, then this book by Hadley Wickham contains everything one needs to know. Other online resources are available and offer varying levels of complexity.\n\n\n\nFigure 5.1 (a): Step 1\nFigure 5.1 (b): Step 2\nFigure 5.2 (a): Basic panels of a shiny app.\nFigure 5.2 (b): Corresponding code in the UI.\nFigure 5.3: Exerpt from UI code of Witte and Stanciu (2023)\nFigure 5.4 (a): Example code reactive and input object.\nFigure 5.4 (b): Corresponding UI code for input objects.\nFigure 5.5 (a): UI code and corresponding server code for output object.\nFigure 5.5 (b): Corresponding plot display in the user interface.\nFigure 5.6: Steps to shiny app deployment on external server.\n\n\n\nStanciu, A., C. J. Cohrs, K. Hanke, and A. Gavreliuc. 2017. “Within-Culture Variation in the Content of Stereotypes: Application and Development of the Stereotype Content Model in an Eastern European Culture.” The Journal of Social Psychology 157 (5): 611–28. https://doi.org/10.1080/00224545.2016.1262812.\n\n\nWitte, E. H., and A. Stanciu. 2023. “Error Theory of Mental Test Scores Without and with a Measurement Instrument.” https://doi.org/10.31219/osf.io/9ap6m.\n\n\nWitte, E. H., Stanciu A., and F. Zenker. 2022. “Predicted as Observed? How to Identify Empirically Adequate Theoretical Constructs.” Frontiers in Psychology 13: 980261. https://doi.org/10.3389/fpsyg.2022.980261.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "apps.html#footnotes",
    "href": "apps.html#footnotes",
    "title": "5  Shiny apps",
    "section": "",
    "text": "python programming language is likewise supported but won’t be covered in this short book. See the official website for more.↩︎\nOne can integrate shiny app features in quarto documents as described here.↩︎\nSome of these apps might take a bit of time until they load because they might be “asleep”. A shiny app is asleep when there is no activity for a pre-determined time thus the server cleans up working memory by putting inactive apps to sleep.↩︎\nConnecting to the server and deploying the app might take some time. Once the app has been successfully deployed, it will open automatically in your default web browser.↩︎\nNote that you need to be logged-in to your GitHub account to see the script files↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Shiny apps</span>"
    ]
  },
  {
    "objectID": "outro.html",
    "href": "outro.html",
    "title": "6  Parting words",
    "section": "",
    "text": "Advanced resources\nIf you still are not convinced of how powerful R can be, then what about this: You can create art using r. That is right! There are several packages available that can help you get in touch with your creative side while not ignoring your love for data!\naRtsy package is downloadable as explained here and attributed to Derks (2023).\nDanielle Navarro provides a workshop for art from code using R: see here.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Parting words</span>"
    ]
  },
  {
    "objectID": "outro.html#advanced-resources",
    "href": "outro.html#advanced-resources",
    "title": "6  Parting words",
    "section": "",
    "text": "Example of r generated art using the package aRtsy.\n\n\n\n\n\n\n\nExample of r generated art using the package aRtsy.\n\n\n\nDerks, Koen. 2023. aRtsy: Generative Art with ’Ggplot2’. https://CRAN.R-project.org/package=aRtsy.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Parting words</span>"
    ]
  },
  {
    "objectID": "author.html",
    "href": "author.html",
    "title": "About the author",
    "section": "",
    "text": "Some of the images used throughout this short book were generated using Microsoft Copilot.\nDr. Adrian STANCIU is assistant professor in lifespan developmental psychology (focus on adult development and digitization) at the University of Luxembourg. He studies how through digital technologies the life quality and health of older migrants can be improved and sustained longterm. He is likewise researching on human values, mental health, and methodology of assessment, often in international collaborations and in an interdisciplinary approach.\n\n\nNote that this short book is self-published online adhering to the creative common licensing CC BY-NC. All the copyrights are reserved by the author, Asst. Prof. Dr. Adrian Stanciu.\n\nIf you are not sure how to use and/ redistribute its contents, see for details here.",
    "crumbs": [
      "About the author"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Conner, M., and Christopher J. Armitage. 1998. “Extending the\nTheory of Planned Behavior: A Review and Avenues for Further\nResearch.” Journal of Applied Social Psychology 28 (15):\n1429–64. https://doi.org/10.1111/j.1559-1816.1998.tb01685.x.\n\n\nDerks, Koen. 2023. aRtsy: Generative Art with ’Ggplot2’. https://CRAN.R-project.org/package=aRtsy.\n\n\nStanciu, A., C. J. Cohrs, K. Hanke, and A. Gavreliuc. 2017.\n“Within-Culture Variation in the Content of Stereotypes:\nApplication and Development of the Stereotype Content Model in an\nEastern European Culture.” The Journal of Social\nPsychology 157 (5): 611–28. https://doi.org/10.1080/00224545.2016.1262812.\n\n\nWitte, E. H., and A. Stanciu. 2023. “Error Theory of Mental Test\nScores Without and with a Measurement Instrument.” https://doi.org/10.31219/osf.io/9ap6m.\n\n\nWitte, E. H., Stanciu A., and F. Zenker. 2022. “Predicted as\nObserved? How to Identify Empirically Adequate Theoretical\nConstructs.” Frontiers in Psychology 13: 980261. https://doi.org/10.3389/fpsyg.2022.980261.",
    "crumbs": [
      "References"
    ]
  }
]